using System;
using System.Globalization;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Threading.Tasks;
using Fathym;
using Fathym.API;
using Fathym.Business.Models;
using Fathym.Design.Singleton;
using LCU.Graphs;
using LCU.Graphs.Registry.Enterprises;
using LCU.Graphs.Registry.Enterprises.Apps;
using LCU.Graphs.Registry.Enterprises.IDE;
using LCU.Graphs.Registry.Enterprises.Identity;
using LCU.Graphs.Registry.Enterprises.Provisioning;
using LCU.Runtime;
using LCU.State.API.Forge.Infrastructure.Models;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Logging;
using Microsoft.TeamFoundation.DistributedTask.WebApi;
using Fathym.Design;
using LCU.Presentation.Personas.Applications;
using LCU.Presentation.Personas.DevOps;
using LCU.Presentation.Personas.Security;
using LCU.Presentation.Personas.Enterprises;

namespace LCU.State.API.Forge.Infrastructure.Harness
{
    public class ForgeInfrastructureStateHarness : LCUStateHarness<ForgeInfrastructureState>
    {
        #region Fields
        protected readonly DevOpsArchitectClient devOpsArch;

        protected readonly EnterpriseManagerClient entMgr;

        protected readonly SecurityManagerClient secMgr;
        #endregion

        #region Properties

        #endregion

        #region Constructors
        public ForgeInfrastructureStateHarness(HttpRequest req, ILogger logger, ForgeInfrastructureState state)
            : base(req, logger, state)
        {
            devOpsArch = req.ResolveClient<DevOpsArchitectClient>(logger);

            entMgr = req.ResolveClient<EnterpriseManagerClient>(logger);

            secMgr = req.ResolveClient<SecurityManagerClient>(logger);
        }
        #endregion

        #region API Methods
        public virtual async Task<ForgeInfrastructureState> AppSeedCompleteCheck(string filesRoot)
        {
            state.LoadingMessage = "Creating Seed Applications";

            var appSeed = state.AppSeed.Options.FirstOrDefault(o => o.Lookup == state.AppSeed.SelectedSeed);

            var completed = await appDev.AppSeedCompleteCheck(new Presentation.Personas.Applications.AppSeedCompleteCheckRequest()
            {
                AppSeed = appSeed,
                RepoName = state.AppSeed.NewName
            }, details.EnterpriseAPIKey, state.Environment.Lookup, details.Host, details.Username);

            if (completed != null)
            {
                state.AppSeed.InfraBuilt = completed.Model.InfraBuilt;

                state.AppSeed.AppSeeded = completed.Model.AppSeeded;

                state.AppSeed.HasBuild = completed.Model.HasBuild;

                state.AppSeed.AppSeedBuilt = completed.Model.AppSeedBuilt;

                state.AppSeed.Step = completed.Model.AppSeedLCU ? ForgeInfrastructureApplicationSeedStepTypes.Created : state.AppSeed.Step;
            }

            return state;
        }

        public virtual async Task<ForgeInfrastructureState> CommitInfrastructure(string selectedTemplate)
        {
<<<<<<< HEAD
            state.LoadingMessage = "Committing Infrastructure";

            var repoName = state.EnvSettings?.Metadata?["GitHubRepository"]?.ToString();

            var repoOrg = state.EnvSettings?.Metadata?["GitHubOrganization"]?.ToString();

            state.InfraTemplate.Options = new List<string>();
=======
            if (state.InfraTemplate.SelectedTemplate.IsNullOrEmpty())
                state.InfraTemplate.SelectedTemplate = selectedTemplate;
>>>>>>> be87346d41eeadf7bfaf1fbf4d957b0ff67dd954

            var committed = await devOpsArch.CommitInfrastructure(new Presentation.Personas.DevOps.CommitInfrastructureRequest()
            {
                EnvironmentLookup = state.Environment.Lookup,
                SelectedTemplate = state.InfraTemplate.SelectedTemplate,
            }, details.EnterpriseAPIKey, state.Environment.Lookup, details.Username);

            return state;
        }

        public virtual async Task<ForgeInfrastructureState> ConfigureDevOps(string npmRegistry, string npmAccessToken)
        {
<<<<<<< HEAD
            state.LoadingMessage = "Configuring Dev Ops";

            log.LogInformation("Configuring Dev Ops");

            var repoName = state.EnvSettings?.Metadata?["GitHubRepository"]?.ToString();

            var repoOrg = state.EnvSettings?.Metadata?["GitHubOrganization"]?.ToString();

            var project = await getOrCreateDevOpsProject();

            var repo = await gitHubClient.Repository.Get(repoOrg, repoName);

            var azure = Azure.Authenticate(getAuthorization());

            var azureSub = azure.Subscriptions.GetById(state.EnvSettings.Metadata["AzureSubID"].ToString());
=======
            var configured = await devOpsArch.ConfigureDevOps(new Presentation.Personas.DevOps.ConfigureDevOpsRequest()
            {
                NPMAccessToken = npmAccessToken,
                NPMRegistry = npmRegistry
            }, details.EnterpriseAPIKey, state.Environment.Lookup, details.Username);
>>>>>>> be87346d41eeadf7bfaf1fbf4d957b0ff67dd954

            state.DevOps.NPMRegistry = npmRegistry;

            state.DevOps.NPMAccessToken = npmAccessToken;

            return state;
        }

        public virtual async Task<ForgeInfrastructureState> ConfigureInfrastructure(string infraType, bool useDefaultSettings, MetadataModel settings)
        {
<<<<<<< HEAD
            state.LoadingMessage = "Configuring Infrastructure";

            if (useDefaultSettings && infraType == "Azure")
            {
                var orgLookup = state.GitHub.SelectedOrg;

                //  TODO: Power with data instead of static....  This way root infra repo can be controlled
                var originOrgName = "lowcodeunit";

                //  TODO: Power with data instead of static....  This way root infra repo can be controlled
                var repoName = "infrastructure";

                var orgInfraRepo = await getOrForkRepository(originOrgName, orgLookup, repoName);

                settings.Metadata["GitHubRepository"] = repoName;
=======
            var envLookup = $"{state.GitHub.SelectedOrg}-prd";
>>>>>>> be87346d41eeadf7bfaf1fbf4d957b0ff67dd954

            var configured = await devOpsArch.ConfigureInfrastructure(new Presentation.Personas.DevOps.ConfigureInfrastructureRequest()
            {
                EnvSettings = settings,
                OrganizationLookup = state.GitHub.SelectedOrg,
                InfraType = infraType,
                UseDefaultSettings = useDefaultSettings
            }, details.EnterpriseAPIKey, envLookup, details.Username);

            if (configured.Status)
            {
                state.Environment = configured.Model;

                var envSettings = await entMgr.GetEnvironmentSettings(details.EnterpriseAPIKey, state.Environment.Lookup);

                state.EnvSettings = envSettings.Model;
            }
            else
                state.Error = configured.Status.Message;

            return state;
        }

        public virtual async Task<ForgeInfrastructureState> CreateAppFromSeed(string filesRoot, string name)
        {
<<<<<<< HEAD
            state.LoadingMessage = "Creating Application";

            var repoOrg = state.EnvSettings?.Metadata?["GitHubOrganization"]?.ToString();

=======
>>>>>>> be87346d41eeadf7bfaf1fbf4d957b0ff67dd954
            var appSeed = state.AppSeed.Options.FirstOrDefault(o => o.Lookup == state.AppSeed.SelectedSeed);

            var repoName = state.AppSeed.NewName = appSeed?.SeedFork?.Repository.ToLower() ?? name.ToLower();

            var created = await appDev.CreateAppFromSeed(new Presentation.Personas.Applications.CreateAppFromSeedRequest()
            {
<<<<<<< HEAD
                log.LogError(ex, "Error in CreateAppFromSeed");
            }

            return state;
        }

        public virtual async Task<ForgeInfrastructureState> CompleteAppSeedCreation(string filesRoot, string repoName)
        {
            state.LoadingMessage = "Completing Application Seed";

            var appSeed = state.AppSeed.Options.FirstOrDefault(o => o.Lookup == state.AppSeed.SelectedSeed);
=======
                AppSeed = appSeed,
                RepoName = repoName
            }, details.EnterpriseAPIKey, state.Environment.Lookup, details.Username);
>>>>>>> be87346d41eeadf7bfaf1fbf4d957b0ff67dd954

            state.AppSeed.Step = ForgeInfrastructureApplicationSeedStepTypes.Creating;

            return state;
        }

        public virtual async Task<ForgeInfrastructureState> Ensure()
        {
            state.LoadingMessage = "";

            if (state.AppSeed == null)
                state.AppSeed = new InfrastructureApplicationSeedState()
                {
                    Options = new List<InfrastructureApplicationSeedOption>()
                };

            await GetEnvironments();

            await HasDevOpsSetup();

            if (state.DevOps == null || !state.DevOps.Configured)
                state.DevOps = new DevOpsState();

            var tpd = await secMgr.RetrieveIdentityThirdPartyData(details.EnterpriseAPIKey, details.Username, "NPM-RC-TOKEN", "NPM-RC-REGISTRY");

            state.DevOps.NPMRegistry = tpd.Model["NPM-RC-REGISTRY"] ?? "https://registry.npmjs.org/";

            state.DevOps.NPMAccessToken = tpd.Model["NPM-RC-TOKEN"];

            var hasSourceControl = await entMgr.HasSourceControlOAuth(details.EnterpriseAPIKey, details.Username);

            if (state.GitHub == null || !hasSourceControl.Status)
                state.GitHub = new GitHubState();

            if (state.InfraTemplate == null || !hasSourceControl.Status)
                state.InfraTemplate = new InfrastructureTemplateState();

            return await WhenAll(
                HasDevOps(),
                GetEnterprise(),
                HasInfrastructure(),
                HasSourceControl(),
                ListGitHubOrganizations(),
                ListGitHubOrgRepos()
            );
        }

        public virtual async Task<ForgeInfrastructureState> GetEnterprise()
        {
<<<<<<< HEAD
            state.LoadingMessage = "Retrieving Enterprise Record";

            var ent = await entGraph.LoadByPrimaryAPIKey(details.EnterpriseAPIKey);
=======
            var ent = await entMgr.GetEnterprise(details.EnterpriseAPIKey);
>>>>>>> be87346d41eeadf7bfaf1fbf4d957b0ff67dd954

            state.EnterpriseName = ent.Model?.Name;

            return state;
        }

        public virtual async Task<ForgeInfrastructureState> GetEnvironments()
        {
<<<<<<< HEAD
            state.LoadingMessage = "Retrieving Environments";

            var envs = await prvGraph.ListEnvironments(details.EnterpriseAPIKey);
=======
            var envs = await entMgr.ListEnvironments(details.EnterpriseAPIKey);
>>>>>>> be87346d41eeadf7bfaf1fbf4d957b0ff67dd954

            if (!envs.Model.IsNullOrEmpty())
            {
                state.Environment = envs.Model.FirstOrDefault();

                var envSettings = await entMgr.GetEnvironmentSettings(details.EnterpriseAPIKey, state.Environment?.Lookup);

                state.EnvSettings = envSettings.Model;
            }
            else
            {
                state.Environment = null;

                state.EnvSettings = null;
            }

            return state;
        }

<<<<<<< HEAD
        public virtual async Task<ForgeInfrastructureState> HasProdConfig(string filesRoot)
        {
            state.LoadingMessage = "Checking For Production Configuration";

            var repoName = state.EnvSettings?.Metadata?["GitHubRepository"]?.ToString();

            var repoOrg = state.EnvSettings?.Metadata?["GitHubOrganization"]?.ToString();

            state.ProductionConfigured = false;

            if (!repoOrg.IsNullOrEmpty())
            {
                var repo = await gitHubClient.Repository.Get(repoOrg, repoName);

                var repoPath = Path.Combine(filesRoot, $"git\\repos\\{repoOrg}\\{repoName}");

                var repoDir = new DirectoryInfo(repoPath);

                await ensureRepo(repoDir, repo.CloneUrl);

                var envPath = Path.Combine(repoDir.FullName, "environments", state.Environment.Lookup);

                var tmplPath = Path.Combine(envPath, "template.json");

                state.ProductionConfigured = File.Exists(tmplPath);
            }

            return state;
        }

        public virtual async Task<ForgeInfrastructureState> HasDevOps()
        {
            state.LoadingMessage = "Checking For Dev Ops";

            state.DevOps.Configured = !devOpsToken.IsNullOrEmpty();
=======
        public virtual async Task<ForgeInfrastructureState> HasDevOps()
        {
            var hasDevOps = await entMgr.HasDevOpsOAuth(details.EnterpriseAPIKey, details.Username);

            state.DevOps.Configured = hasDevOps.Status;
>>>>>>> be87346d41eeadf7bfaf1fbf4d957b0ff67dd954

            return state;
        }

        public virtual async Task<ForgeInfrastructureState> HasDevOpsSetup()
        {
<<<<<<< HEAD
            state.LoadingMessage = "Ensuring Dev Ops Setup";

            var repoName = state.EnvSettings?.Metadata?["GitHubRepository"]?.ToString();

            var repoOrg = state.EnvSettings?.Metadata?["GitHubOrganization"]?.ToString();

            TeamProjectReference project = null;

            if (projClient != null)
=======
            if (state.Environment != null)
>>>>>>> be87346d41eeadf7bfaf1fbf4d957b0ff67dd954
            {
                var isDevOpsSetup = await entMgr.IsDevOpsSetup(details.EnterpriseAPIKey, state.Environment.Lookup, details.Username);

                state.DevOps.Setup = isDevOpsSetup?.Status;
            }

            return state;
        }

        public virtual async Task<ForgeInfrastructureState> HasInfrastructure()
        {
            var envs = await entMgr.ListEnvironments(details.EnterpriseAPIKey);

            state.InfrastructureConfigured = !envs.Model.IsNullOrEmpty() && envs.Model.Any(env =>
            {
                return env != null;
            });

            return state;
        }

        public virtual async Task<ForgeInfrastructureState> HasProdConfig()
        {
<<<<<<< HEAD
            state.LoadingMessage = "Checking For Infrastructure";

            var envs = await prvGraph.ListEnvironments(details.EnterpriseAPIKey);

            state.InfrastructureConfigured = !envs.IsNullOrEmpty() && envs.Any(env =>
=======
            if (state.Environment != null)
>>>>>>> be87346d41eeadf7bfaf1fbf4d957b0ff67dd954
            {
                var hasProdEnv = await entMgr.HasProductionEnvironment(details.EnterpriseAPIKey, state.Environment?.Lookup, details.Username);

                state.ProductionConfigured = hasProdEnv.Status;
            }
            else
                state.ProductionConfigured = false;

            return state;
        }

        public virtual async Task<ForgeInfrastructureState> HasSourceControl()
        {
<<<<<<< HEAD
            state.LoadingMessage = "Checking For Source Control";

            state.SourceControlConfigured = !gitHubToken.IsNullOrEmpty();
=======
            var hasSC = await entMgr.HasSourceControlOAuth(details.EnterpriseAPIKey, details.Username);

            state.SourceControlConfigured = hasSC.Status;
>>>>>>> be87346d41eeadf7bfaf1fbf4d957b0ff67dd954

            return state;
        }

        public virtual async Task<ForgeInfrastructureState> ListGitHubOrganizations()
        {
<<<<<<< HEAD
            state.LoadingMessage = "Retrieving GitHub Organizations";

            if (gitHubClient != null)
            {
                var orgs = await gitHubClient.Organization.GetAllForCurrent();
=======
            var gitHubOrgs = await entMgr.ListGitHubOrganizations(details.EnterpriseAPIKey, details.Username);
>>>>>>> be87346d41eeadf7bfaf1fbf4d957b0ff67dd954

            state.GitHub.Organizations = gitHubOrgs.Model;

            return state;
        }

        public virtual async Task<ForgeInfrastructureState> ListGitHubOrgRepos()
        {
<<<<<<< HEAD
            state.LoadingMessage = "Retrieving GitHub Repositories";

            if (gitHubClient != null && !state.GitHub.SelectedOrg.IsNullOrEmpty())
=======
            if (!state.GitHub.SelectedOrg.IsNullOrEmpty())
>>>>>>> be87346d41eeadf7bfaf1fbf4d957b0ff67dd954
            {
                var gitHubOrgRepos = await entMgr.ListGitHubOrganizationRepos(details.EnterpriseAPIKey, state.GitHub.SelectedOrg, details.Username);

                state.GitHub.OrgRepos = gitHubOrgRepos.Model;
            }

            return state;
        }

        public virtual async Task<ForgeInfrastructureState> LoadInfrastructureRepository()
        {
<<<<<<< HEAD
            state.LoadingMessage = "Loading Infrastructure Repository";

            var repoName = state.EnvSettings?.Metadata?["GitHubRepository"]?.ToString();

            var repoOrg = state.EnvSettings?.Metadata?["GitHubOrganization"]?.ToString();

            state.InfraTemplate.Options = new List<string>();

            if (!repoOrg.IsNullOrEmpty())
=======
            if (state.Environment != null)
>>>>>>> be87346d41eeadf7bfaf1fbf4d957b0ff67dd954
            {
                var infaConfig = await entMgr.LoadInfrastructureConfig(details.EnterpriseAPIKey, state.Environment?.Lookup, details.Username);

                state.InfraTemplate.Options = infaConfig.Model.InfraTemplateOptions;

                state.AppSeed.Options = infaConfig.Model.AppSeedOptions;
            }

            return state;
        }

        public virtual async Task<ForgeInfrastructureState> SetSelectedInfrastructureTemplate(string template)
        {
            state.LoadingMessage = "Setting Infrastructure Template";

            state.InfraTemplate.SelectedTemplate = template;

            return state;
        }

        public virtual async Task<ForgeInfrastructureState> SetSelectedOrg(string org)
        {
            state.LoadingMessage = "Creating Seed Applications";

            state.GitHub.SelectedOrg = org;

            return state;
        }

        public virtual async Task<ForgeInfrastructureState> SetSetupStep(ForgeInfrastructureSetupStepTypes? step)
        {
            state.LoadingMessage = "Setting Setup Step";

            state.SetupStep = step;

            return state;
        }

        public virtual async Task<ForgeInfrastructureState> SetupAppSeed(string seedLookup)
        {
            state.LoadingMessage = "Setting Up Application Seed";

            state.AppSeed.SelectedSeed = seedLookup;

            return state;
        }

        public virtual async Task<ForgeInfrastructureState> SetupDevOpsOAuth(string devOpsAppId, string devOpsClientSecret, string devOpsScopes)
        {
<<<<<<< HEAD
            state.LoadingMessage = "Setting Up Dev Ops OAuth";

            var status = await entGraph.SetThirdPartyData(details.EnterpriseAPIKey, "LCU-DEV-OPS-APP-ID", devOpsAppId);

            if (status)
                status = await entGraph.SetThirdPartyData(details.EnterpriseAPIKey, "LCU-DEV-OPS-APP-CLIENT-SECRET", devOpsClientSecret);

            if (status)
                status = await entGraph.SetThirdPartyData(details.EnterpriseAPIKey, "LCU-DEV-OPS-APP-SCOPES", devOpsScopes);
=======
            var devOpsOAuth = await entMgr.SetupDevOpsOAuthConnection(new Presentation.Personas.Enterprises.SetupDevOpsOAuthConnectionRequest()
            {
                DevOpsAppID = devOpsAppId,
                DevOpsClientSecret = devOpsClientSecret,
                DevOpsScopes = devOpsScopes
            }, details.EnterpriseAPIKey);
>>>>>>> be87346d41eeadf7bfaf1fbf4d957b0ff67dd954

            state.DevOps.OAuthConfigured = devOpsOAuth.Status;

            return state;
        }

        public virtual async Task<ForgeInfrastructureState> SetupGitHubOAuth(string gitHubClientId, string gitHubClientSecret)
        {
<<<<<<< HEAD
            state.LoadingMessage = "Setting Up GitHub OAuth";

            var status = await entGraph.SetThirdPartyData(details.EnterpriseAPIKey, "LCU-GIT-HUB-CLIENT-ID", gitHubClientId);

            if (status)
                status = await entGraph.SetThirdPartyData(details.EnterpriseAPIKey, "LCU-GIT-HUB-CLIENT-SECRET", gitHubClientSecret);

            state.GitHub.OAuthConfigured = status;

            return state;
        }
        #endregion

        #region Helpers
        protected virtual async Task checkoutAndSync(string repoPath, LibGit2Sharp.Handlers.CredentialsHandler credsProvider)
        {
            using (var gitRepo = new LibGit2Sharp.Repository(repoPath))
            {
                LibGit2Sharp.Commands.Checkout(gitRepo, gitRepo.Branches["master"]);

                var author = await loadGitHubSignature();

                LibGit2Sharp.Commands.Pull(gitRepo, author, new LibGit2Sharp.PullOptions()
                {
                    FetchOptions = new LibGit2Sharp.FetchOptions()
                    {
                        CredentialsProvider = credsProvider
                    }
                });
            }
        }

        protected virtual async Task commitAndSync(string message, string repoPath, LibGit2Sharp.Handlers.CredentialsHandler credsProvider)
        {
            using (var gitRepo = new LibGit2Sharp.Repository(repoPath))
=======
            var gitHubOAuth = await entMgr.SetupGitHubOAuthConnection(new Presentation.Personas.Enterprises.SetupGitHubOAuthConnectionRequest()
>>>>>>> be87346d41eeadf7bfaf1fbf4d957b0ff67dd954
            {
                GitHubClientID = gitHubClientId,
                GitHubClientSecret = gitHubClientSecret
            }, details.EnterpriseAPIKey);

            state.GitHub.OAuthConfigured = gitHubOAuth.Status;

            return state;
        }
        #endregion

        #region Helpers
        #endregion
    }
}